(self.webpackChunkrptools_doc=self.webpackChunkrptools_doc||[]).push([[6276],{49866:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=t(87462),r=(t(67294),t(3905)),s=t(93456);const i={},l="Handshake and Authentication",o={unversionedId:"authentication/handshake",id:"authentication/handshake",title:"Handshake and Authentication",description:"Last Updated: MapTool 1.11",source:"@site/docs/authentication/handshake.mdx",sourceDirName:"authentication",slug:"/authentication/handshake",permalink:"/docs/authentication/handshake",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MTScript Library functions",permalink:"/docs/add-ons/mtscript-lib-functions"},next:{title:"MapTool Data",permalink:"/docs/data/"}},h={},c=[{value:"Blocked Player",id:"blocked-player",level:2},{value:"Player using public key authentication",id:"player-using-public-key-authentication",level:2},{value:"Connecting with MapTool Easy Connect (uses public key)",id:"connecting-with-maptool-easy-connect-uses-public-key",level:2},{value:"Player using shared password authentication",id:"player-using-shared-password-authentication",level:2},{value:"Protocol Buffers",id:"protocol-buffers",level:2}],d={toc:c};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"handshake-and-authentication"},"Handshake and Authentication"),(0,r.kt)("p",null,"Last Updated: MapTool 1.11"),(0,r.kt)("p",null,"The handshake and authentication occurs via protocol buffers messages before any Hessian serialization occurs. Once the handshake and authentication is successful only then will Hessian serialization be used for passing messages between server and client. (This is likely to change in MapTool 1.11 or MapTool 1.12 where Hessian will be completely replaced by protocol buffers)"),(0,r.kt)("h2",{id:"blocked-player"},"Blocked Player"),(0,r.kt)("p",null,"If a player is blocked then the Server will inform the client of this before trying perform any password or public key authentication."),(0,r.kt)(s.Mermaid,{config:{},chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player from ClientInitMsg<br/>\n    Server->>Client: Send PlayerBlockedMsg\n    Client->>Client: Inform Player<br/>and disconnect.",mdxType:"Mermaid"}),(0,r.kt)("h2",{id:"player-using-public-key-authentication"},"Player using public key authentication"),(0,r.kt)("p",null,"If the player is not blocked and is authenticating with a public key then the following authentication/handshake sequence occurs. The public key has to be known to the Server before a player can attempt to authenticate this way."),(0,r.kt)("p",null,"if Not using MapTool easy connect the public key is not sent from client to server via MapTool so the server must know of the public key before hand. The server then encrypts the handshake challenge using the public key which the client will only be able to decrypt if it has access to the matching private key, once decrypted the client sends back the handshake challenge in plaintext as it needs to do no more to show it has the correct private key."),(0,r.kt)(s.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player from ClientInitMsg<br/>and retrieve the public key\n    Server->>Server: Create HandshakeChallenge\n    Server->>Server: Encrypt Challenge with public key\n    Server->>Client: Send UseAuthTypeMsg\n    Note right of Server: auth_type = ASYMMETRIC_KEY<br/> challenge[0] = HandshakeChallenge.challenge\n    Client->>Client: Decrypt Handshake Challeng and reverse random string\n    Client->>Server: Send ClientAuthMsg\n    Note left of Client:(not encrypted)<br/>challenge_response = HandshakeChallenge.response (reversed string)\n    Server->>Client: Send ConnectionSuccessfulMsg",mdxType:"Mermaid"}),(0,r.kt)("h2",{id:"connecting-with-maptool-easy-connect-uses-public-key"},"Connecting with MapTool Easy Connect (uses public key)"),(0,r.kt)("p",null,"If the player is already defined in the player database (and having the same public key that they are trying to connect with) the authentication process follows the above flow of connecting with a public key. Otherwise the following flow is followed."),(0,r.kt)(s.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player + Public Key from ClientInitMsg<br/>fails.\n    Server->>Client: RequestPublicKeyMsg (with PIN code expected).\n    Client->>Server: PublicKeyUploadMsg\n    Server->>Client: PublicKeyAddedMsg\n    Note right of Server: From here on the flow is the same as the public key<br/>flow above.\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player from ClientInitMsg<br/>and retrieve the public key\n    Server->>Server: Create HandshakeChallenge\n    Server->>Server: Encrypt Challenge with public key\n    Server->>Client: Send UseAuthTypeMsg\n    Note right of Server: auth_type = ASYMMETRIC_KEY<br/> challenge[0] = HandshakeChallenge.challenge\n    Client->>Client: Decrypt Handshake Challenge and reverse the random string\n    Client->>Server: Send ClientAuthMsg\n    Note left of Client:(not encrypted)<br/>challenge_response = HandshakeChallenge.response (reversed string)\n    Server->>Client: Send ConnectionSuccessfulMsg",mdxType:"Mermaid"}),(0,r.kt)("h2",{id:"player-using-shared-password-authentication"},"Player using shared password authentication"),(0,r.kt)("p",null,"If the player is not blocked and is authenticating with a shared password the following authentication/handshake sequence occurs. As a shared password could be per player or role based (i.e. a single password for players and another single password for GMs) the server creates a challenge for both GM and Player and which ever the client can respond to determines the role. If a password database is used where the role is recorded and the Server knows if the player is a GM or not then a new random password will be used to encrypt the non pertinent handshake challenge ensuring it should never match."),(0,r.kt)("p",null,"Password information is never sent between the client and the server instead it is used on both sides to encrypt/decrypt the handshake challenge."),(0,r.kt)(s.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n  Client->>Server: ClientInitMsg\nServer->>Server: Lookup Player from ClientInitMsg and<br/>retrieve password salt\nServer->>Server: Create HandshakeChallenge<br/>Player Password\nnote right of Server: If using player database<br/> with known players and player<br/>is GM then a new random<br/>password is used so this<br/> would never match.\nServer->>Server: Create HandshakeChallenge<br/>GM Password\nnote right of Server: If using player database<br/> with known players and player<br/>is not a GM then a new random<br/>password is used so this<br/> would never match.\nServer->>Client: Send UseAuthTypeMsg\nnote right of Client: auth_type = SHARED_PASSWORD<br/> salt = retrieved password salt<br/> challenge[0] = HandshakeChallenge.challenge (gm)<br/> challenge[1] = HandshakeChallenge.challenge (player)<br/>\nClient->>Client: Hash password with<br/>PBKDF2WithHmacSHA1<br/>using salt sent by Server\nClient->>Client: Try decrypt both challenges and reverse random string\nClient->>Client: Encrypt HandshakeChallenge.response\nClient->>Server: Send ClientAuthMsg\nnote right of Server: challenge_response = Encrypted HandshakeChallenge.response (reversed string)\nServer->>Server: Compare client challenge response to<br/>pre-encrypted challenge response on server<br/>side to determine which password was used this will be reversed string\nServer->>Client: Send ConnectionSuccessfulMsg",mdxType:"Mermaid"}),(0,r.kt)("h2",{id:"protocol-buffers"},"Protocol Buffers"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf",metastring:'reference title="Handshake Protocol Buffers"',reference:!0,title:'"Handshake',Protocol:!0,'Buffers"':!0},"https://github.com/RPTools/maptool/blob/develop/src/main/proto/handshake.proto\n")))}p.isMDXComponent=!0},11748:(e,n,t)=>{var a={"./locale":89234,"./locale.js":89234};function r(e){var n=s(e);return t(n)}function s(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=s,e.exports=r,r.id=11748}}]);